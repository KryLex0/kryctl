#!/usr/bin/env bash
# This script was generated by bashly 1.1.6 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
kryctl_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl - Sample application\n"
    echo

  else
    printf "kryctl - Sample application\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl COMMAND\n"
  printf "  kryctl [COMMAND] --help | -h\n"
  printf "  kryctl --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "kryctl Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  echo
  printf "%s\n" "Commands:"
  printf "  %s   Manage terminal\n" "terminal   "
  printf "  %s   Manage terminal\n" "git        "
  printf "  %s   Manage spaces\n" "space      "
  printf "  %s   Manage Kubernetes\n" "kube       "
  printf "  %s   Manage Multipass\n" "multipass  "
  printf "  %s   Deploy S3 Manager\n" "s3         "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
kryctl_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl completions - Generate bash completions\n"
    echo

  else
    printf "kryctl completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl completions\n"
  printf "  kryctl completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  eval \"$(kryctl completions)\"\n"
    echo

  fi
}

# :command.usage
kryctl_terminal_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl terminal - Manage terminal\n"
    echo

  else
    printf "kryctl terminal - Manage terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl terminal COMMAND\n"
  printf "  kryctl terminal [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Prompt for switching terminal\n" "change"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl terminal change\n"
    echo

  fi
}

# :command.usage
kryctl_terminal_change_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl terminal change - Prompt for switching terminal\n"
    echo

  else
    printf "kryctl terminal change - Prompt for switching terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl terminal change\n"
  printf "  kryctl terminal change --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_git_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl git - Manage terminal\n"
    echo

  else
    printf "kryctl git - Manage terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl git COMMAND\n"
  printf "  kryctl git [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Save changes locally, pull, and apply local changes back\n" "stash"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl git stash\n"
    echo

  fi
}

# :command.usage
kryctl_git_stash_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl git stash - Save changes locally, pull, and apply local changes back\n"
    echo

  else
    printf "kryctl git stash - Save changes locally, pull, and apply local changes back\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl git stash\n"
  printf "  kryctl git stash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_space_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl space - Manage spaces\n"
    echo

  else
    printf "kryctl space - Manage spaces\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl space COMMAND\n"
  printf "  kryctl space [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Clear disk space (apt, journal, docker, ...)\n" "clear"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl space clear\n"
    echo

  fi
}

# :command.usage
kryctl_space_clear_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl space clear - Clear disk space (apt, journal, docker, ...)\n"
    echo

  else
    printf "kryctl space clear - Clear disk space (apt, journal, docker, ...)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl space clear\n"
  printf "  kryctl space clear --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_kube_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl kube - Manage Kubernetes\n"
    echo

  else
    printf "kryctl kube - Manage Kubernetes\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl kube COMMAND\n"
  printf "  kryctl kube [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Switch Kubernetes context\n" "context   "
  printf "  %s   Find string in Kubernetes resources\n" "find      "
  printf "  %s   Change Kubernetes configuration\n" "set-config"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl kube context\n"
    printf "  kryctl kube find\n"
    echo

  fi
}

# :command.usage
kryctl_kube_context_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl kube context - Switch Kubernetes context\n"
    echo

  else
    printf "kryctl kube context - Switch Kubernetes context\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl kube context\n"
  printf "  kryctl kube context --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_kube_find_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl kube find - Find string in Kubernetes resources\n"
    echo

  else
    printf "kryctl kube find - Find string in Kubernetes resources\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl kube find\n"
  printf "  kryctl kube find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_kube_set_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl kube set-config - Change Kubernetes configuration\n"
    echo

  else
    printf "kryctl kube set-config - Change Kubernetes configuration\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl kube set-config\n"
  printf "  kryctl kube set-config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_multipass_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl multipass - Manage Multipass\n"
    echo

  else
    printf "kryctl multipass - Manage Multipass\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl multipass\n"
  printf "  kryctl multipass --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl multipass\n"
    echo

  fi
}

# :command.usage
kryctl_s3_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl s3 - Deploy S3 Manager\n"
    echo

  else
    printf "kryctl s3 - Deploy S3 Manager\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl s3 COMMAND\n"
  printf "  kryctl s3 [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List S3 profiles\n" "profiles"
  printf "  %s   Run S3 Manager UI\n" "ui      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kryctl s3 profiles\n"
    printf "  kryctl s3 ui --profile=default\n"
    printf "  kryctl s3 ui --endpoint=oos.eu-west-2.outscale.com\n  --credentials-path=/path/to/credentials\n"
    echo

  fi
}

# :command.usage
kryctl_s3_profiles_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl s3 profiles - List S3 profiles\n"
    echo

  else
    printf "kryctl s3 profiles - List S3 profiles\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl s3 profiles\n"
  printf "  kryctl s3 profiles --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
kryctl_s3_ui_usage() {
  if [[ -n $long_usage ]]; then
    printf "kryctl s3 ui - Run S3 Manager UI\n"
    echo

  else
    printf "kryctl s3 ui - Run S3 Manager UI\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kryctl s3 ui [OPTIONS]\n"
  printf "  kryctl s3 ui --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--profile, -p PROFILE"
    printf "    Profile to use\n"
    echo

    # :flag.usage
    printf "  %s\n" "--endpoint, -e ENDPOINT"
    printf "    S3 endpoint\n"
    echo

    # :flag.usage
    printf "  %s\n" "--credentials-path, -c CREDENTIALS-PATH"
    printf "    S3 credentials path\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/send_completions.sh
send_completions() {
  echo $'# kryctl completion                                        -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_kryctl_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_kryctl_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'terminal change\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'kube set-config\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'kube context\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s3 profiles\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'space clear\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'git stash\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'multipass\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'kube find\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'terminal\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h change")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'space\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h clear")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s3 ui\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--credentials-path --endpoint --help --profile -c -e -h -p")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'kube\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h context find set-config")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'git\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h stash")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s3\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help -h profiles ui")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_kryctl_completions_filter "--help --version -h -v completions git kube multipass s3 space terminal")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _kryctl_completions kryctl'
  echo $''
  echo $'# ex: filetype=sh'
}

# :command.command_functions
# :command.function
kryctl_completions_command() {
  # src/completions_command.sh
  echo "# this file is located in 'src/completions_command.sh'"
  echo "# code for 'kryctl completions' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  send_completions
}

# :command.function
kryctl_terminal_change_command() {
  # src/terminal_change_command.sh
  sudo update-alternatives --config x-terminal-emulator

  # #  check if ${args[list]} is true
  # if [[ ${args[list]} == true ]]; then
  #     sudo update-alternatives --list x-terminal-emulator
  # else
  #     #  check if ${args[set]} is true
  #     if [[ ${args[set]} == true ]]; then
  #         sudo update-alternatives --set x-terminal-emulator ${args[terminal]}
  #     else
  #         #  check if ${args[config]} is true
  #         if [[ ${args[config]} == true ]]; then
  #             sudo update-alternatives --config x-terminal-emulator
  #         fi
  #     fi
  # fi

}

# :command.function
kryctl_git_stash_command() {
  # src/git_stash_command.sh
  pwd

  echo "Do you want to pull from github and save your changes locally? (y/n)"
  read answer
  if [ "$answer" == "y" ]; then
      # save current changes locally
      git stash save
      # pull latest changes from github
      git pull
      # apply saved changes
      git stash pop

      echo "Github pull complete and local changes applied"
  else
      echo "Skipping pull from github"
  fi
}

# :command.function
kryctl_space_clear_command() {
  # src/space_clear_command.sh
  sudo apt-get clean

  sudo apt-get autoclean

  sudo journalctl --vacuum-time=1d

  sudo apt-get autoremove --purge

  docker image rm -f $(docker images -f dangling=true -q)

  # if argument is passed
  if [ "$1" == "all" ]; then
      # run a command with y to all questions
      yes | docker system prune --volumes
  else

      docker system prune --volumes
      echo "Docker cleared"
  fi

}

# :command.function
kryctl_kube_context_command() {
  # src/kube_context_command.sh
  # list all kube context and allow user to change context
  kubectl config get-contexts
  echo "Enter the context you want to use"
  read context
  kubectl config use-context $context
}

# :command.function
kryctl_kube_find_command() {
  # src/kube_find_command.sh
  #k get clusters.management.cattle.io -n fleet-default c-m-chzpn7mr -o yaml
  echo "Script to find a specific string in all CRDs of the current cluster"

  FILTER_STRING=""

  # check if argument is supplied
  if [ $# -eq 0 ]; then
    # Ask the filter string
    read -p "Enter the filter string: " FILTER_STRING
    echo "Filter string: $FILTER_STRING"
  fi

  # Lst all crd
  CRDS=$(kubectl get crd -o jsonpath='{.items[*].metadata.name}')

  for CRD in $CRDS; do
    echo "CRD: $CRD"
    kubectl get $CRD -A -o yaml | grep -i "$FILTER_STRING"

    # kubectl get $CRD -A -o yaml | grep "sample-cluster1-pool-master-7478dc8dfbxkzf6c-bp2r5"
  done

  # - outscalemachines.rke-machine.cattle.io
  # - machines.cluster.x-k8s.io
}

# :command.function
kryctl_kube_set_config_command() {
  # src/kube_set_config_command.sh
  # list all kubeconfig starting by config_ files in ~/.kube/ and print them if exist
  kubeconfigs=($(ls ~/.kube/config_* 2>/dev/null))

  if [ ${#kubeconfigs[@]} -eq 0 ]; then
      echo "No kubeconfig found"
  else
      echo "Available kubeconfig:"
      # print all kubeconfig like "X. name"
      for i in ${!kubeconfigs[@]}; do
          echo "$i. ${kubeconfigs[$i]}"
      done
  fi

  echo "Enter the kubeconfig number you want to use"
  read kubeconfig_number
  cp ${kubeconfigs[$kubeconfig_number]} ~/.kube/config
}

# :command.function
kryctl_multipass_command() {
  # src/multipass_command.sh
  # Print the list of available systems
  echo "To restart multipass: 'sudo snap restart multipass.multipassd'"

  multipass list

  echo "multipass set local.driver=qemu || multipass set local.driver=lxd"

  create_instance() {
      # while getopts i:n:d:r: flag
      # do
      #     case "${flag}" in
      #         i) image=${OPTARG};;
      #         n) name=${OPTARG};;
      #         d) disk=${OPTARG};;
      #         r) ram=${OPTARG};;
      #     esac
      # done

      # echo "Image = $image"
      # echo "Name = $name"
      # echo "Disk = $disk"
      # echo "Ram = $ram"

      #size of disk and ram in GB
      disk="$3"G
      ram="$4"G

      # Create a new instance
      echo "Creating instance $2"
      echo multipass launch $1 --name $2 --disk $disk --memory $ram
      multipass launch $1 --name $2 --disk $disk --memory $ram
  }

  # Run the instance
  run_instance() {
      echo "Starting instance $1"
      multipass shell $1
  }

  restart_instance() {
      echo "Restarting instance $1"
      multipass restart $1
  }

  stop_instance() {
      echo "Stoping instance $1"
      multipass stop $1
  }

  # Delete the instance
  delete_instance() {
      echo "Stoping instance $1"
      multipass stop $1
      echo "Deleting instance $1"
      multipass delete --purge $1
  }

  # Modify RAM/CPU
  modify_instance() {

      echo "Stoping instance $1"
      multipass stop $1

      # if not equal to 0
      if [ "$2" -ne 0 ]; then

          #add G to the disk
          disk="$2"G
          multipass set local.$1.disk=$disk
          echo "Allocation of disk: $disk for '$1'"
      fi

      if [ "$3" -ne 0 ]; then
          #add G to the ram
          ram="$3"G
          multipass set local.$1.memory=$ram
          echo "Allocation of memory: $ram for '$1'"
      fi
      if [ "$cpu" -ne 0 ]; then
          multipass set local.$1.cpus=$cpu
          echo "Allocation of CPU: $cpu for '$1'"
      fi

      echo "Starting instance $1"
      multipass start $1

  }

  # WORKS
  cp_files() {
      PATHFILE=$1
      VM=$2
      CHOICE=$3
      # Transfer files
      if [ $CHOICE -eq 1 ]; then
          echo "Transfer files From local to VM"

          echo "multipass transfer --recursive $PATHFILE $VM:."
          #if folder transfert recursively
          if [ -d $PATHFILE ]; then
              multipass transfer --recursive $PATHFILE $VM:.
          else
              multipass transfer $PATHFILE $VM:.
          fi

      elif [ $CHOICE -eq 2 ]; then
          echo "Transfer files From VM to local"

          echo "multipass transfer --recursive $VM:$PATHFILE ."
          #if folder transfert recursively
          # if [ -d $PATHFILE ]; then
          multipass transfer --recursive $VM:$PATHFILE .
          # else
              # multipass transfer $VM:$PATHFILE .
          # fi
      fi

  }

  manage_instance() {
      # if argument suply with command name and system name
      if [ $# -eq 2 ]; then
          if [ $1 = "restart" ]; then
              restart_instance $2
          elif [ $1 = "create" ]; then
              if [ $2 = "" || $3 = "" || $4 = "" || $5 = "" ]; then
                  echo "Invalid command"
                  echo "Usage: cmd-multipass create <image> <instance_name> <disk_size> <ram_size>"
                  exit
              fi
              create_instance $2 $3 $4 $5
          elif [ $1 = "run" ]; then
              if [ "$(multipass list | grep $1 | wc -l) -eq 1" ]; then
                  run_instance $2
                  exit
              else
                  echo "Instance does not exist"
                  exit
              fi
          elif [ $1 = "cp" ]; then
              cp_files $2 $3
          elif [ $1 = "modify" ]; then
              modify_instance $2
          elif [ $1 = "rm" ]; then
              delete_instance $2
          elif [ $1 = "stop" ]; then
              stop_instance $2
          else
              echo "Invalid command"
          fi
          exit
      fi
  }

  init_prompt() {
      echo "use this command to create a debian 11 VM:"
      echo "multipass launch --name debian11 -vvvv https://cloud.debian.org/images/cloud/bullseye/latest/debian-11-generic-amd64.qcow2"
      # Ask what to do
      echo "What do you want to do?"
      # echo "0. Start/Stop Multipass service"
      echo "1. Create a new instance" #Works
      echo "2. Run an instance"   #Works
      echo "3. Transfer files"   #Works
      echo "4. Modify an instance"

      echo "5. Start an instance" #Works
      echo "6. Stop an instance" #Works
      echo "7. Delete an instance"
      read -p "Enter your choice: " choice

      # echo "Usage: cmd-multipass create <image> <instance_name> <disk_size> <ram_size>"

      read -p "Enter the name of the instance: " name

      if [ $choice -eq 0 ]; then
          multipass set client.gui.autostart=false
      fi
      if [ $choice -eq 1 ]; then
          read -p "Enter the image name (default: ubuntu 22): " image

          read -p "Enter the disk size in GB (default: 10GB): " disk_size
          read -p "Enter the RAM size in GB (default: 4GB): " ram_size
          read -p "Enter the CPU (default: 1): " cpu
      fi
      if [ $choice -eq 4 ]; then
          read -p "Enter the image name (default: ubuntu 22): " image

          read -p "Enter the disk size in GB (default: 10GB): " disk_size
          read -p "Enter the RAM size in GB (default: 4GB): " ram_size
          read -p "Enter the CPU (default: 1): " cpu
      fi

      if [ $choice -eq 1 ]; then

          if [ -z "$image" ]; then
              image="jammy"
          fi
          if [ -z "$name" ]; then
              name="ubuntu-instance"
          fi
          if [ -z "$disk_size" ]; then
              disk_size=10
          fi
          if [ -z "$ram_size" ]; then
              ram_size=4
          fi
          create_instance $image $name $disk_size $ram_size
          run_instance $name
          exit 0
      fi
      #while name is not set
      while [ -z "$name" ]
      do
          read -p "Enter the name of the instance: " name
      done

      # default value for disk, ram and cpu
      if [ -z "$disk_size" ]; then
          disk_size=0
      fi
      if [ -z "$ram_size" ]; then
          ram_size=0
      fi
      if [ -z "$cpu" ]; then
          cpu=0
      fi

      if [ $choice -eq 2 ]; then
          run_instance $name
      elif [ $choice -eq 3 ]; then
          read -p "Enter the path of the file: " document
          echo "1) From local to VM"
          echo "2) From VM to local"
          read -p "Enter your choice: " choice
          cp_files $document $name $choice
      elif [ $choice -eq 4 ]; then
          modify_instance $name $disk_size $ram_size $cpu
      elif [ $choice -eq 5 ]; then
          restart_instance $name
      elif [ $choice -eq 6 ]; then
          stop_instance $name
      elif [ $choice -eq 7 ]; then
          delete_instance $name
      else
          echo "Invalid choice"
      fi
  }

  init_prompt

  # # Run the script
  # if [ $# -eq 0 ]; then
  #     init_prompt
  # elif [ $# -eq 1 ]; then
  #     echo "Invalid command"
  #     echo "Usage: cmd-multipass [run|cp] <instance_name> <file_path>"
  # elif [ $# -eq 2 ]; then
  #     manage_instance $1 $2
  # elif [ $# -eq 3 ]; then
  #     cp_files $1 $3 $2
  # else
  #     echo "Invalid command"
  # fi

}

# :command.function
kryctl_s3_profiles_command() {
  # src/s3_profiles_command.sh
  ENDPOINT_URL="https://oos.eu-west-2.outscale.com"

  # Liste tous les profils disponibles dans ~/.aws/credentials
  echo "Profils disponibles :"
  grep -oP '^\[\K[^\]]+' ~/.aws/credentials | sed 's/^/\t- /'
}

# :command.function
kryctl_s3_ui_command() {
  # src/s3_ui_command.sh
  # ENDPOINT_URL="https://oos.eu-west-2.outscale.com"
  DEFAULT_ENDPOINT_URL="oos.eu-west-2.outscale.com"

  # inspect_args
  AWS_CREDENTIALS=${args["--credentials-path"]}
  ENDPOINT_URL=${args["--endpoint"]}
  PROFILE=${args["--profile"]}

  if [ -z "$AWS_CREDENTIALS" ]; then
    echo "AWS_CREDENTIALS not set, using default location $HOME/.aws/credentials"
    AWS_CREDENTIALS="$HOME/.aws/credentials"
  else
    # verify it exists
    if [ ! -f "$AWS_CREDENTIALS" ]; then
      echo "Error: AWS_CREDENTIALS file not found at $AWS_CREDENTIALS"
      exit 1
    else
      echo "Using AWS_CREDENTIALS file at $AWS_CREDENTIALS"
    fi
  fi

  if [ -z "$ENDPOINT_URL" ]; then
    echo "ENDPOINT_URL not set, using default $DEFAULT_ENDPOINT_URL"
  fi

  # Vérifie que le profil existe dans $AWS_CREDENTIALS
  if ! grep -q "^\[$PROFILE\]" $AWS_CREDENTIALS; then
    echo "Erreur : Le profil '$PROFILE' n'existe pas dans $AWS_CREDENTIALS."
    kryctl s3 profiles
    exit 1
  fi

  # Récupère les clés depuis $AWS_CREDENTIALS
  ACCESS_KEY_ID=$(awk -v profile="[$PROFILE]" '$0 == profile {getline; print $3}' $AWS_CREDENTIALS)
  SECRET_ACCESS_KEY=$(awk -v profile="[$PROFILE]" '$0 == profile {getline; getline; print $3}' $AWS_CREDENTIALS)

  # Vérifie si les clés ont été trouvés
  if [ -z "$ACCESS_KEY_ID" ] || [ -z "$SECRET_ACCESS_KEY" ]; then
    echo "Erreur : Impossible de trouver les clés pour le profil '$PROFILE'."
    exit 1
  fi

  echo "AK/SK found for profile '$PROFILE' :"
  echo "  ACCESS_KEY_ID=$ACCESS_KEY_ID"
  echo "  SECRET_ACCESS_ID=$SECRET_ACCESS_KEY"
  echo "  ENDPOINT_URL=$ENDPOINT_URL"

  echo "Do you want to continue? [y/N]"
  read -r response
  VALID_RESPONSES=("y" "Y" "o" "O")

  if [[ ! " ${VALID_RESPONSES[@]} " =~ " ${response} " ]]; then
    echo "Aborting."
    exit 0
  fi

  # Lance le conteneur Docker avec les clés et l'endpoint récupérés
  docker run --rm -d --name s3-manager-ui -p 8080:8080 \
    -e "ACCESS_KEY_ID=$ACCESS_KEY_ID" \
    -e "SECRET_ACCESS_KEY=$SECRET_ACCESS_KEY" \
    -e "ENDPOINT=$ENDPOINT_URL" \
    cloudlena/s3manager

  echo "Docker container started in detached mode."
  echo "You can access the UI at http://localhost:8080"

  exit 0

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        kryctl_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      kryctl_completions_parse_requirements "$@"
      shift $#
      ;;

    terminal)
      action="terminal"
      shift
      kryctl_terminal_parse_requirements "$@"
      shift $#
      ;;

    git)
      action="git"
      shift
      kryctl_git_parse_requirements "$@"
      shift $#
      ;;

    space)
      action="space"
      shift
      kryctl_space_parse_requirements "$@"
      shift $#
      ;;

    kube)
      action="kube"
      shift
      kryctl_kube_parse_requirements "$@"
      shift $#
      ;;

    multipass)
      action="multipass"
      shift
      kryctl_multipass_parse_requirements "$@"
      shift $#
      ;;

    s3)
      action="s3"
      shift
      kryctl_s3_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_terminal_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_terminal_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    change)
      action="change"
      shift
      kryctl_terminal_change_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_terminal_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_terminal_change_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_terminal_change_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="terminal change"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_git_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    stash)
      action="stash"
      shift
      kryctl_git_stash_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_git_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_git_stash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_git_stash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="git stash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_space_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_space_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    clear)
      action="clear"
      shift
      kryctl_space_clear_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_space_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_space_clear_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_space_clear_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space clear"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_kube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_kube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    context)
      action="context"
      shift
      kryctl_kube_context_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      kryctl_kube_find_parse_requirements "$@"
      shift $#
      ;;

    set-config)
      action="set-config"
      shift
      kryctl_kube_set_config_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_kube_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_kube_context_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_kube_context_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kube context"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_kube_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_kube_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kube find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_kube_set_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_kube_set_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kube set-config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_multipass_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_multipass_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="multipass"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_s3_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_s3_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    profiles)
      action="profiles"
      shift
      kryctl_s3_profiles_parse_requirements "$@"
      shift $#
      ;;

    ui)
      action="ui"
      shift
      kryctl_s3_ui_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kryctl_s3_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_s3_profiles_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_s3_profiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="s3 profiles"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kryctl_s3_ui_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kryctl_s3_ui_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="s3 ui"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --profile | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--profile']="$2"
          shift
          shift
        else
          printf "%s\n" "--profile requires an argument: --profile, -p PROFILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --endpoint | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--endpoint']="$2"
          shift
          shift
        else
          printf "%s\n" "--endpoint requires an argument: --endpoint, -e ENDPOINT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --credentials-path | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--credentials-path']="$2"
          shift
          shift
        else
          printf "%s\n" "--credentials-path requires an argument: --credentials-path, -c CREDENTIALS-PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "completions") kryctl_completions_command ;;
    "terminal") kryctl_terminal_command ;;
    "terminal change") kryctl_terminal_change_command ;;
    "git") kryctl_git_command ;;
    "git stash") kryctl_git_stash_command ;;
    "space") kryctl_space_command ;;
    "space clear") kryctl_space_clear_command ;;
    "kube") kryctl_kube_command ;;
    "kube context") kryctl_kube_context_command ;;
    "kube find") kryctl_kube_find_command ;;
    "kube set-config") kryctl_kube_set_config_command ;;
    "multipass") kryctl_multipass_command ;;
    "s3") kryctl_s3_command ;;
    "s3 profiles") kryctl_s3_profiles_command ;;
    "s3 ui") kryctl_s3_ui_command ;;
  esac
}

initialize
run "$@"
